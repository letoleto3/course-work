\documentclass[a4paper, 12pt, twoside]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{cite,enumerate,float}

\usepackage{vmargin}
\usepackage{indentfirst}
\usepackage[T2A]{fontenc}
\usepackage{graphics}
\usepackage{amsthm}
\usepackage{amsbsy}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathtext}
\usepackage{hhline}
\usepackage[pdftex,a4paper,colorlinks,linkcolor=blue,citecolor=blue]{hyperref}	

\usepackage{mathtext}
\usepackage{mathenv}
\usepackage[pdftex]{graphicx}
\usepackage{array}
\usepackage{graphicx,xcolor}
\usepackage{xcolor}
\usepackage{float}
\usepackage{longtable}
\usepackage{fancybox,fancyhdr} 

\parindent = 30pt
\hoffset = 12pt
\voffset = 0pt
\oddsidemargin = 0pt
\evensidemargin = 0pt
\topmargin = 9pt
\headheight = 0pt
\headsep = 24pt
\textheight = 650pt
\textwidth = 450pt
\marginparsep = 0pt
\marginparwidth = 9pt
\footskip = 30pt

\newtheorem{algorithm}{Algorithm}
\newtheorem{theorem}{Theorem}
\newcommand*\diff{\mathop{}\!\mathrm{d}}
\DeclareMathOperator{\divg}{div}


\begin{document}

\begin{titlepage} \newpage 
\begin{center} МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ\\ ИМ. М.В. ЛОМОНОСОВА\end{center} 
\vspace{8em} \begin{center} 
\Large Механико-математический факультет \\ \end{center}
\vspace{2em} \begin{center} 
\textsc{Курсовая работа \linebreak \textbf{}
\linebreak \linebreak \textbf{}} \end{center}
\vspace{6em} \newbox{\lbox} \savebox{\lbox}{\hbox{Я.Нагорных}} 
\newlength{\maxl} \setlength{\maxl}{\wd\lbox} \hfill\parbox{12	cm}
{ \hspace*{10cm}\hspace*{-5cm}Студент 3 курса:\hfill\hbox to\maxl{Нагорных Я.В.}\\
\hspace*{10cm}\hspace*{-5cm}Научный руководитель:\hfill\hbox to\maxl{Богачев К.Ю.}}\\  \vspace{\fill}
\begin{center} Москва \\ 2017\end{center} \end{titlepage}

%\maketitle

%\renewcommand{\contentsname}{Содержание}
\tableofcontents

\renewcommand{\figurename}{Рисунок}
\newcommand{\class}{\textcolor[rgb]{0.5,0,0.5}}
\newcommand{\type}{\textcolor[rgb]{0.5,0.5,0}}
\newcommand{\field}{\textcolor[rgb]{0.5,0,0}}

\newpage

\section*{Введение}
\addcontentsline{toc}{section}{Введение}
Печать большив массивов чисел всегда занимает много времени.
Кроме того, у печати данных мало ресурсов для ускорения.

Печать чисел с плавающей запятой также является проблемой, так как само значение числа и его экспоненту нельзя обрабатывать независимо. 

Стандартный подход недостаточно точен и в некоторых случаях дает неверные результаты. 
Кроме того использование функций стандартных библиотек (\texttt{printf}, \texttt{sprintf}) достаточно затратно по времени.
\\
\\
\textbf{Цели работы:}
\begin{enumerate}
\item Ускорить печать больших массивов;
\item Использовать быстрые алгоритмы печати целых чисел и чисел с плавающей точкой.
\end{enumerate}

\section{Проблемы и способы их решения}
Как уже было сказано, у печати массивов мало ресурсов для ускорения.
Также проблемой является и то, что печать данных файл должна быть строго последовательной, поэтому нельзя ''простым'' образом использовать распараллеливание.

Однако, известно что большую часть времени занимает преобразование типа \texttt{\type{int}} или \texttt{\type{double}} в буффер типа \texttt{\type{const char} *} непосредственно для печати.
Именно это можно и распараллелить, используя многопоточное программирование.
Непосредственно печать в сам файл упирается в возможности диска. 
Ее ускорить нельзя.

Кроме того, можно заменить стандартный алгоритм преобразования числа в строку, на более быстрые.
Мы будем использовать алгоритм \textsf{Grisu2} для печати вещественных чисел и \textsf{SSE2} для печати целых чисел, о которых будет рассказано позже.


\section{Описание алгоритма}
\subsection{Используемые структуры и классы}
\paragraph{Структура \texttt{\class{writer\_chunk}}.}
В ней находится элемент класса \texttt{\class{writer\_file}}, строковый буффер (готовый для печати) и его порядковый номер (\texttt{\field{chunk\_id}}).
Кроме того, хранится флаг, является ли этот \texttt{\class{writer\_chunk}} последним.
\paragraph{Класс \texttt{\class{writer\_file}}.}
Он организовывает правильную и последовательную печать готовых буферов в файл. 
\paragraph{Структура \texttt{\class{printer\_chunk}}.}
Этот тип состоит из лямбда-функии, которая должна обработать определенный фрагмент массива чисел, и элемента типа \texttt{\class{writer\_chunk}}, возвращаемый функцией.
\paragraph{Класс \texttt{\class{mutex\_wait\_queue}}.}
Это реализация \textit{блокирующей очереди}, или \textit{мьютексной очереди}.  
Под ней понимается очередь со следующим свойством: когда поток пытается прочитать что-то из пустой очереди, то он блокируется, до тех пор, пока какой-нибудь другой поток не положит в нее элемент.
У этой очереди есть следующие методы:
\begin{itemize}
\item \texttt{dequeue} -- достает верхний элемент из очереди, если очередь непустая.
Иначе, поток, вызвавший этот метод блокируется. Также можно передать время блокировки, по истечении которого, поток разблокируется и вернется ни с чем;
\item \texttt{dequeue\_all} -- аналогично \texttt{dequeue}, но достает все элементы, находящиеся в очереди, и складывает в указатель вектор из них;
\item \texttt{enqueue} -- складывает элемент в конец очереди.
\end{itemize}
\paragraph{Класс \texttt{\class{parallel\_writer}}.} 
Он хранит в себе поток \texttt{\field{m\_writer}} и вектор потоков \texttt{\field{m\_printer}}.
Поток \texttt{\field{m\_writer}} будет заниматься печатью в файл.
Потоки \texttt{\field{m\_printers}} занимаются тем, что конвертируют элементы типа \texttt{\class{printer\_chunk}} (числа) в элементы типа \texttt{\class{writer\_chunk}} (строки).
Помимо потоков и их количества этот класс хранит две блокирующие очереди \texttt{\field{m\_print\_queue}} и \texttt{\field{m\_write\_queue}}, состоящие из \texttt{\class{printer\_chunk}} и \texttt{\class{writer\_chunk}} соответственно. 
Зачем нужны такие очереди будет сказано позже.

\subsection{Распределение задач}
Управляющий (главный) поток будет складывать элементы типа \texttt{\class{printer\_chunk}} в очередь \texttt{\field{m\_print\_queue}}.
Потоки \texttt{\field{m\_printers}} будут доставать из этой очереди \texttt{\class{printer\_chunk}}-и на обработку.
Они должны конвертировать числа в буфферы, готовые для печати.
Эти готовые буфферы \texttt{\class{writer\_chunk}} они складывают в другую очередь \texttt{\field{m\_write\_queue}}.
\texttt{\textcolor[rgb]{0.5,0,0}{parallel\_writer}}
Поток \texttt{\field{m\_writer}} должен забирать готовые буфферы из этой очереди и печатать их в правильном порядке в файл.
\begin{figure}[h!]
\def\svgwidth{430pt}
  \input{drawing.pdf_tex}
  \caption{Работа потоков.} \label{draw}
\end{figure}

Схематично работа потоков показана на Рисунке \ref{draw}.

\subsection{Преобразование чисел в строковый тип}
В статье \cite{1} описан алгоритм \textsf{Grisu} и его улучшения, также доказана их точность.
Опишем кратко эти алгоритмы.
\paragraph{Идея алгоритма.}
Предполагается, не умаляя общности, что у числа с плавающей точкой $v$ отрицательный показатель. 
Тогда это число можно выразить как $v=\cfrac{f_v}{2^{-e_v}}$, где $f_v$ -- мантисса, а $e_v$ -- экспонента. 
Десятичные цифры $v$ могут быть вычислены путем нахождения десятичного показателя $t$, для которого $1 \leqslant \cfrac{f_v \times 10^t}{2^{-e_v}} < 10$.

Первая цифра является целой частью этой дроби. 
Последующие цифры вычисляются путем повторного использования оставшейся дроби: нужно умножить числитель на $10$ и взять целую часть от вновь полученной дроби.

Идея \textsf{Grisu} состоит в том, чтобы кешировать приблизительные значения $\cfrac{10^t}{2^{e_t}}$.
Дорогих операций с большими числами не будет: они заменяются операциями с целыми числами фиксированного размера.

Кэш для всевозможных значений $t$ и $e_t$ может быть дорогостоящим. 
Из-за этого требования к кеш-памяти в \textsf{Grisu} упрощены. 
Кэш хранит только нормированные приближения с плавающей точкой всех соответствующих степеней десяти: $\tilde{c_k} := \left[ 10^k \right]_q^{\star}$, где $q$ -- точность кэшированных чисел.
Кэшированные числа сокращают большую часть экспоненты $v$, так что остается только небольшой показатель. 

Процесс генерации цифр использует степени десяти с экспонентой $e_{\tilde{c_t}}$, близкой к $e_v$. 
Разница между двумя показателями будет небольшой.

Фактически, \textsf{Grisu} выбирает степени десяти так, что разница лежит в определенном диапазоне. 
Разные диапазоны дают разные подпрограммы для генерации цифр.
Также стоит учесть, что наименьшая разница не всегда является наиболее эффективным выбором.

Определим \texttt{diy\_fp} для $x$ как беззнаковое целое число $f_x$, состоящее из $q$ битов, и знакового целого числа $e_x$ неограниченного диапазона. 
Значение $x$ можно вычислить как $x= f_x \times 2^{e_x}$.

В следующем алгоритме мы параметризуем оставшийся показатель по переменным $\alpha$ и $\gamma$. 
Положим $\gamma \geqslant \alpha + 3$, а затем представим интересные варианты для этих параметров. 
Для начального обсуждения предположим, что $\alpha := 0$ и $\gamma := 3$.

\paragraph{Реализация.}
Алгоритм \textsf{Grisu}: \begin{itemize}
\item \textit{Вход:} положительное число с плавающей точкой $v$ точности $p$.
\item \textit{Условие:} точность \texttt{diy\_fp} удовлетворяет $q \geqslant p + 2$, а кеш степеней десяти состоит из предварительно вычисленных нормированных округленных  \texttt{diy\_fp} значений $\tilde{c_k} := \left[ 10^k \right]_q^{\star}$
\item \textit{Вывод:} строковое представление в основании 10 для $V$ такое, что $[V]^{\Box}_p = v$. 
То есть $V$ должен быть округлен до $v$ при чтении вновь.
\end{itemize}

Шаги алгоритма:
\begin{enumerate}
\item \textit{Преобразование:} определим нормированный \texttt{diy\_fp} $w$ такой, что $w = v$.
\item \textit{Кэширование степеней:} находим нормированное $\tilde{c}_{-k} = f_c \times 2^{e_c}$ такое, что $\alpha \leqslant e_c + e_w + q \leqslant \gamma$.
\item \textit{Произведение:} пусть $\tilde{D} = f_D \times 2^{e_D} := w \otimes \tilde{c}_{-k}$.
\item \textit{Выход:} определим искомое $V := \tilde{D} \times 10^k$. 
Вычислим десятичное представление $\tilde{D}$, за которым следует строка ''e'' и десятичное представление $k$.
\end{enumerate}
Поскольку значение \texttt{diy\_fp} больше, чем значение входного числа, преобразование шага 1 дает точный результат. 
По определению \texttt{diy\_fp}-ы имеют бесконечный диапазон экспоненциальности и показатель степени $w$, следовательно, достаточно велик для нормирования. 
Заметим, что показатель $e_w$ удовлетворяет $e_w \leqslant e_v - (q - p)$. 

Легко показать, что $\forall i, 0 < \tilde{e}_{c_i} - \tilde{e}_{c_{i-1}} \leqslant 4$, и поскольку кеш неограничен, требуемый $\tilde{c}_{-k}$ должен находиться в кеше. 
Это является причиной первоначального требования $\gamma \geqslant \alpha + 3$.

Разумеется, бесконечный кеш не нужен. 
$k$ зависит только от типа номера с плавающей точкой ввода (его диапазон экспоненты), точности \texttt{diy\_fp} и пары $\alpha$ и $\gamma$.

Результатом \textsf{Grisu} является строка, содержащая десятичное представление $\tilde{D}$, за которым следуют символ ''e'' и $k$ знаков. 
Таким образом, он представляет собой число $V: = \tilde{D} \times 10^k$. 
Утверждается, что $V$ дает $v$ при округлении до числа с плавающей точкой с точностью $p$.

Для преобразования целых чисел используется алгоритм \textsf{SSE2}, о котором подробнее написано в статье \cite{2}.
Суть алгоритма заключается в быстром логарифмировании числа по основанию 10.

Кроме того, если в массиве есть $n$ подряд идущих одинаковых чисел $x$, то будем записывать их как \texttt{n*x}.
Такая запись может сэкономить память и время работы. 

\section{Результаты работы и ускорение}
Время работы в секундах для массива с разными случайными числами представлено в следующей таблице:
\begin{center}
\begin{tabular}{||c|c|c|c|c|c||}
\hline
\hline
Размер & \multicolumn{4}{c|}{Число потоков} & Стандартная\\
\hhline{~|-|-|-|-|~|}
массива & 16 & 12 & 4 & 1 & печать \\
\hline
\hline
& 0.609 & 0.550 & 0.880 & 3.196 & 4.256 \\
\hhline{~|-|-|-|-|-|}
10000000 & 0.567 & 0.500 & 0.841 & 3.239 & 4.176 \\
\hhline{~|-|-|-|-|-|}
& 0.506 &0.473 & 0.802 & 3.052 & 4.188 \\
\hline
& 2.420 & 2.528 & 4.044 & 15.377 & 22.476 \\
\hhline{~|-|-|-|-|-|}
50000000 & 2.522 & 2.446 & 4.273 & 16.309 & 21.116\\
\hhline{~|-|-|-|-|-|}
& 2.587 & 2.339 & 4.179 & 15.327 & 20.893 \\
\hline
& 5.025 & 4.665 & 8.276 & 32.461 & 41.712 \\
\hhline{~|-|-|-|-|-|}
100000000 & 4.787 & 4.630 & 7.970 & 30.571 & 41.785 \\
\hhline{~|-|-|-|-|-|}
& 4.844 & 4.544 & 8.078 & 30.757 & 41.961 \\
\hline
\hline
\end{tabular}
\end{center}

Время работы на массиве с множеством повторяющихся чисел:
\begin{center}
\begin{tabular}{||c|c|c|c|c|c||}
\hline
\hline
Размер & \multicolumn{4}{c|}{Число потоков} & Стандартная\\
\hhline{~|-|-|-|-|~|}
массива & 16 & 12 & 4 & 1 & печать \\
\hline
\hline
& 0.318 & 0.249 & 0.188 & 0.652 & 3.645 \\
\hhline{~|-|-|-|-|-|}
10000000 & 0.334 & 0.256 & 0.190 & 0.629 & 3.622 \\
\hhline{~|-|-|-|-|-|}
& 0.307 & 0.251 & 0.192 & 0.661 & 3.620 \\
\hline
& 1.657 & 1.274 & 0.884 & 3.183 & 18.412 \\
\hhline{~|-|-|-|-|-|}
50000000 & 1.505 & 1.247 & 0.891 & 3.167 & 18.306 \\
\hhline{~|-|-|-|-|-|}
& 1.522 & 1.262 & 0.894 & 3.175 & 18.261 \\
\hline
& 3.105 & 2.441 & 1.726 & 6.306 & 36.194 \\
\hhline{~|-|-|-|-|-|}
100000000 & 2.983 & 2.453 & 1.820 & 6.329 & 36.388 \\
\hhline{~|-|-|-|-|-|}
& 3.246 & 2.505 & 1.759 & 6.339 &  36.419 \\
\hline
\hline
\end{tabular}
\end{center}

\section{Заключение}
\newpage

\appendix
\section*{Приложение}
\addcontentsline{toc}{section}{Приложение}
\renewcommand{\thesubsection}{(\Alph{subsection})}

\newpage
\begin{thebibliography}{}

\bibitem{1} \textsc{Florian Loitsch}.
Printing Floating-Point Numbers Quickly and Accurately with Integers, 2004.
\bibitem{2} \textsc{Wojciech Mula}.
SSE: conversion integers to decimal representation, 2011.
\bibitem{3} 
\bibitem{4} \textsc{Богачев К. Ю.}. 
Основы параллельного программирования. -- M.: Бином. Лаборатория знаний, 2010.


\end{thebibliography}

\end{document}
