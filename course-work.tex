\documentclass[a4paper, 12pt, twoside]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{cite,enumerate,float}

\usepackage{vmargin}
\usepackage{indentfirst}
\usepackage[T2A]{fontenc}
\usepackage{graphics}
\usepackage{amsthm}
\usepackage{amsbsy}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathtext}
\usepackage[pdftex,a4paper,colorlinks,linkcolor=blue,citecolor=blue]{hyperref}	

\usepackage{mathtext}
\usepackage{mathenv}
\usepackage[pdftex]{graphicx}
\usepackage{array}
\usepackage{graphicx,xcolor}
\usepackage{xcolor}
\usepackage{float}
\usepackage{longtable}
\usepackage{fancybox,fancyhdr} 

\parindent = 30pt
\hoffset = 12pt
\voffset = 0pt
\oddsidemargin = 0pt
\evensidemargin = 0pt
\topmargin = 9pt
\headheight = 0pt
\headsep = 24pt
\textheight = 650pt
\textwidth = 450pt
\marginparsep = 0pt
\marginparwidth = 9pt
\footskip = 30pt

\newtheorem{algorithm}{Algorithm}
\newtheorem{theorem}{Theorem}
\newcommand*\diff{\mathop{}\!\mathrm{d}}
\DeclareMathOperator{\divg}{div}


\begin{document}

\begin{titlepage} \newpage 
\begin{center} МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ\\ ИМ. М.В. ЛОМОНОСОВА\end{center} 
\vspace{8em} \begin{center} 
\Large Механико-математический факультет \\ \end{center}
\vspace{2em} \begin{center} 
\textsc{Курсовая работа \linebreak \textbf{}
\linebreak \linebreak \textbf{}} \end{center}
\vspace{6em} \newbox{\lbox} \savebox{\lbox}{\hbox{Я.Нагорных}} 
\newlength{\maxl} \setlength{\maxl}{\wd\lbox} \hfill\parbox{12	cm}
{ \hspace*{10cm}\hspace*{-5cm}Студент 3 курса:\hfill\hbox to\maxl{Нагорных Я.В.}\\
\hspace*{10cm}\hspace*{-5cm}Научный руководитель:\hfill\hbox to\maxl{Богачев К.Ю.}}\\  \vspace{\fill}
\begin{center} Москва \\ 2017\end{center} \end{titlepage}

%\maketitle

%\renewcommand{\contentsname}{Содержание}
\tableofcontents

\renewcommand{\figurename}{Рисунок}
\newcommand{\class}{\textcolor[rgb]{0.5,0,0.5}}
\newcommand{\type}{\textcolor[rgb]{0.5,0.5,0}}
\newcommand{\field}{\textcolor[rgb]{0.5,0,0}}

\newpage

\section*{Введение}
\addcontentsline{toc}{section}{Введение}
Печать большив массивов чисел всегда занимает много времени.
Кроме того, у печати данных мало ресурсов для ускорения.

Печать чисел с плавающей запятой также является проблемой, так как само значение числа и его экспоненту нельзя обрабатывать независимо. 

Стандартный подход недостаточно точен и в некоторых случаях дает неверные результаты. 
Кроме того использование функций стандартных библиотек (\texttt{printf}, \texttt{sprintf}) достаточно затратно по времени.
\\
\\
\textbf{Цели работы:}
\begin{enumerate}
\item Ускорить печать больших массивов;
\item Использовать быстрые алгоритмы печати целых чисел и чисел с плавающей точкой.
\end{enumerate}

\section{Проблемы и способы их решения}
Как уже было сказано, у печати массивов мало ресурсов для ускорения.
Также проблемой является и то, что печать данных файл должна быть строго последовательной, поэтому нельзя ''простым'' образом использовать распараллеливание.

Однако, известно что большую часть времени занимает преобразование типа \texttt{\type{int}} или \texttt{\type{double}} в буффер типа \texttt{\type{const char} *} непосредственно для печати.
Именно это можно и распараллелить, используя многопоточное программирование.
Непосредственно печать в сам файл упирается в возможности диска. 
Ее ускорить нельзя.

Кроме того, можно заменить стандартный алгоритм преобразования числа в строку, на более быстрые.
Мы будем использовать алгоритм \textsf{Grisu2}, о котором будет рассказано позже.


\section{Описание алгоритма}

\subsection{Используемые структуры и классы}
\paragraph{Структура \texttt{\class{writer\_chunk}}.}
В ней находится элемент класса \texttt{\class{writer\_file}}, строковый буффер (готовый для печати) и его порядковый номер (\texttt{\field{chunk\_id}}).
Кроме того, хранится флаг, является ли этот \texttt{\class{writer\_chunk}} последним.
\paragraph{Класс \texttt{\class{writer\_file}}.}
Он организовывает правильную печать в файл. 
\paragraph{Структура \texttt{\class{printer\_chunk}}.}
Этот тип состоит из лямбда-функии, которая должна обработать определенный фрагмент массива чисел, и элемента типа \texttt{\class{writer\_chunk}}, который должна вернуть функция.
\paragraph{Класс \texttt{\class{mutex\_wait\_queue}}.}
Это реализация \textit{блокирующей очереди}, или \textit{мьютексной очереди}.  
Под ней понимается очередь со следующим свойством: когда поток пытается прочитать что-то из пустой очереди, то он блокируется, до тех пор, пока какой-нибудь другой поток не положит в нее элемент.
У этой очереди есть следующие методы:
\begin{itemize}
\item \texttt{dequeue} -- достает верхний элемент из очереди, если очередь непустая.
Иначе, поток, вызвавший этот метод блокируется. Также можно передать время блокировки, по истечении которого, поток разблокируется и вернется ни с чем;
\item \texttt{dequeue\_all} -- аналогично \texttt{dequeue}, но достает все элементы, находящиеся в очереди, и складывает в указатель вектор из них;
\item \texttt{enqueue} -- складывает элемент в конец очереди.
\end{itemize}
\paragraph{Класс \texttt{\class{parallel\_writer}}.} 
Он хранит в себе поток \texttt{\field{m\_writer}}, вектор потоков \texttt{\field{m\_printer}}.
Поток \texttt{\field{m\_writer}} будет заниматься печатью в файл.
Потоки \texttt{\field{m\_printers}} занимаются тем, что конвертируют элементы типа \texttt{\class{printer\_chunk}} (числа) в элементы типа \texttt{\class{writer\_chunk}} (строки).
Помимо потоков и их количества этот класс хранит две блокирующие очереди \texttt{\field{m\_print\_queue}} и \texttt{\field{m\_write\_queue}}, состоящие из \texttt{\class{printer\_chunk}} и \texttt{\class{writer\_chunk}} соответственно. 
Зачем нужны такие очереди будет сказано позже.

\subsection{Распределение задач}
Управляющий (главный) поток будет складывать элементы типа \texttt{\class{printer\_chunk}} в очередь \texttt{\field{m\_print\_queue}}.
Потоки \texttt{\field{m\_printers}} будут доставать из этой очереди \texttt{\class{printer\_chunk}}-и на обработку.
Они должны конвертировать числа в буфферы, готовые для печати.
Эти готовые буфферы \texttt{\class{writer\_chunk}} они складывают в другую очередь \texttt{\field{m\_write\_queue}}.
\texttt{\textcolor[rgb]{0.5,0,0}{parallel\_writer}}
Поток \texttt{\field{m\_writer}} должен забирать готовые буфферы из этой очереди и печатать их в правильном порядке в файл.
\begin{figure}[h!]
\def\svgwidth{430pt}
  \input{drawing.pdf_tex}
  \caption{Работа потоков.} \label{draw}
\end{figure}

Схематично работа потоков показана на Рисунке \ref{draw}.

\subsection{Описание \textsf{Grisu2}}
В статье \cite{1} описан алгоритм \textsf{Grisu} и его улучшения, также доказана их точно.
Опишем кратко эти алгоритмы.

Предполагается, не умаляя общности, что у числа с плавающей точкой $v$ отрицательный показатель. 
Тогда это число можно выразить как $v=\cfrac{f_v}{2^{-e_v}}$, где $f_v$ -- мантисса, а $e_v$ -- экспонента. 
Десятичные цифры $v$ могут быть вычислены путем нахождения десятичного показателя $t$, для которого $1 \leqslant \cfrac{f_v \times 10^t}{2^{-e_v}} < 10$.

Первая цифра является целой частью этой дроби. 
Последующие цифры вычисляются путем повторного использования оставшейся дроби: нужно умножить числитель на $10$ и взять целую часть от вновь полученной дроби.

Идея \textsf{Grisu} состоит в том, чтобы кешировать приблизительные значения $\cfrac{10^t}{2^{e_t}}$.
Дорогих операций с большими числами не будет: они заменяются операциями с целыми числами фиксированного размера.

Кэш для всевозможных значений $t$ и $e_t$ может быть дорогостоящим. 
Из-за этого требования к кеш-памяти в \textsf{Grisu} упрощены. Кэш хранит только нормированные приближения с плавающей точкой всех соответствующих степеней десяти: $\tilde{c_k} := \left[ 10^k \right]_q^{\star}$, где $q$ -- точность кэшированных чисел.

Процесс генерации цифр использует степени десяти с экспонентой $e_{\tilde{c_t}}$, близкой к $e_v$. 
Разница между двумя показателями будет небольшой.

Фактически, \textsf{Grisu} выбирает степени десяти так, что разница лежит в определенном диапазоне. 
Разные диапазоны дают разные подпрограммы для генерации цифр, а наименьшая разница не всегда является наиболее эффективным выбором.

\subsection{Описание \textsf{SSE2}}

\section{Результаты работы и ускорение}

\section{Заключение}


\newpage

\appendix
\section*{Приложение}
\addcontentsline{toc}{section}{Приложение}
\renewcommand{\thesubsection}{(\Alph{subsection})}

\newpage
\begin{thebibliography}{}

\bibitem{1} \textsc{Florian Loitsch}.
Printing Floating-Point Numbers Quickly and Accurately with Integers, 2004.
\bibitem{2} \textsc{Wojciech Mula}.
SSE: conversion integers to decimal representation, 2011.
\bibitem{3} https://github.com/miloyip/itoa-benchmark/blob/master/readme.md
\bibitem{4} \textsc{Богачев К. Ю.}. 
Основы параллельного программирования. -- M.: Бином. Лаборатория знаний, 2010.


\end{thebibliography}

\end{document}
