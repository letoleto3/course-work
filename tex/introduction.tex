\section*{Введение}
\addcontentsline{toc}{section}{Введение}
\paragraph{Постановка проблемы.}
Печать больших массивов чисел без округления с большой точностью всегда занимает много времени.
Однако, не вся печать упирается в возможности диска, как это может показаться.
Кроме того, у печати данных мало ресурсов для ускорения.

Печать чисел с плавающей точкой также является проблемой, так как само значение числа и его экспоненту нельзя обрабатывать независимо. 

Кроме того, стандартная реализация с использованием таких функций, как 
\begin{center}
\texttt{sprintf (char *, const char *, \dots)}
\end{center}
или \begin{center}
\texttt{strtod (const char *, char **)},
\end{center} достаточно затратна по времени.

\vspace{5pt}
\textbf{Цели работы:}
\begin{enumerate}
\item Ускорить печать больших массивов без потери точности;
\item Использовать быстрые алгоритмы печати целых чисел и чисел с плавающей точкой.
\end{enumerate}

\paragraph{Возможные варианты улучшений.}
Мы уже обратили внимание на то, что стандартные функции преобразования буфера в строковый тип  работаеют крайне долго. 
Возникает идея применения более быстрых алгоритмов преобразования чисел в строки. 
Так например быстрое логарифмирование, разбиение числа на цифры, может заметно ускорить процесс.

Можно уменьшить число обращений к диску.
Как известно, данные, отправленные на запись, накапливаются в памяти и записываются тогда, когда получен символ переноса строки или что-то в этом роде.
Значит, можно отправлять не по одному числу на печать, а сразу готовым буфером.

Другой идеей для улучшения является использование многопоточного программирования. 
Из-за того, что печать в файл должна быть строго последовательной, кажется, что ресурсов для распараллеливания немного.
Нельзя разбить исходный массив на равные части и параллельно начать печать.
Однако, так как большая часть времени уходит на преобразование чисел в строки, то можно распараллелить именно ее.
Непосредственно запись в сам файл упирается в возможности диска. 
Ее ускорить нельзя.

Также можно задуматься над улучшениями и оптимизировать сам алгоритм, несколько модифицировав вид выходного массива.
За счет этого можно уменьшить размер полученного файла.
Если будет встречаться подряд несколько одинаковых чисел, то можно не записывать в файл их все.
Также, немного уменьшит размер файла отбрасывание ненужных нулей в конце записи числа после точки.

